import { metrics } from '@opentelemetry/api';

// Créer un meter pour les métriques custom
const meter = metrics.getMeter('sofia-agent-metrics', '1.0.0');

// ============================================
// MÉTRIQUES POUR MESURER LE WORKLOAD
// ============================================

/**
 * Compteur de messages reçus par agent
 * Permet de mesurer le nombre total de messages traités
 */
export const messagesReceivedCounter = meter.createCounter('sofia.messages.received', {
  description: 'Total number of messages received by agent',
  unit: '1',
});

/**
 * Compteur de messages envoyés par agent
 * Permet de mesurer le nombre total de réponses générées
 */
export const messagesSentCounter = meter.createCounter('sofia.messages.sent', {
  description: 'Total number of messages sent by agent',
  unit: '1',
});

/**
 * Histogram pour la durée de traitement des messages
 * Permet de mesurer le temps de réponse (P50, P95, P99)
 */
export const messageProcessingDuration = meter.createHistogram('sofia.message.processing.duration', {
  description: 'Duration of message processing in milliseconds',
  unit: 'ms',
});

/**
 * Compteur de requêtes LLM (Gaianet)
 * CRITIQUE pour calculer le workload Gaianet
 */
export const llmRequestsCounter = meter.createCounter('sofia.llm.requests', {
  description: 'Total number of LLM API requests to Gaianet',
  unit: '1',
});

/**
 * Histogram pour la durée des requêtes LLM
 * Permet de mesurer la latence des appels Gaianet
 */
export const llmRequestDuration = meter.createHistogram('sofia.llm.request.duration', {
  description: 'Duration of LLM API requests in milliseconds',
  unit: 'ms',
});

/**
 * Compteur de tokens utilisés (input)
 * CRITIQUE pour calculer le coût et la charge Gaianet
 */
export const llmTokensInputCounter = meter.createCounter('sofia.llm.tokens.input', {
  description: 'Total number of input tokens sent to LLM',
  unit: 'tokens',
});

/**
 * Compteur de tokens générés (output)
 * CRITIQUE pour calculer le coût et la charge Gaianet
 */
export const llmTokensOutputCounter = meter.createCounter('sofia.llm.tokens.output', {
  description: 'Total number of output tokens generated by LLM',
  unit: 'tokens',
});

/**
 * Gauge pour le nombre de connexions WebSocket actives
 * Permet de mesurer la charge en temps réel
 */
export const activeConnectionsGauge = meter.createObservableGauge('sofia.websocket.active_connections', {
  description: 'Number of active WebSocket connections',
  unit: '1',
});

/**
 * Compteur d'erreurs
 * Permet de mesurer le taux d'erreur
 */
export const errorsCounter = meter.createCounter('sofia.errors', {
  description: 'Total number of errors',
  unit: '1',
});

/**
 * Compteur de triplets générés
 * Métrique spécifique à SofIA pour mesurer la production
 */
export const tripletsGeneratedCounter = meter.createCounter('sofia.triplets.generated', {
  description: 'Total number of semantic triplets generated',
  unit: '1',
});

/**
 * Histogram pour la taille des messages
 * Permet de mesurer la complexité des requêtes
 */
export const messageSizeHistogram = meter.createHistogram('sofia.message.size', {
  description: 'Size of messages in characters',
  unit: 'characters',
});

// ============================================
// HELPERS POUR FACILITER L'UTILISATION
// ============================================

/**
 * Enregistre une requête de message
 */
export function recordMessageReceived(agentName: string, messageSize: number) {
  messagesReceivedCounter.add(1, { agent: agentName });
  messageSizeHistogram.record(messageSize, { agent: agentName, direction: 'incoming' });
}

/**
 * Enregistre une réponse envoyée
 */
export function recordMessageSent(agentName: string, messageSize: number, processingTime: number) {
  messagesSentCounter.add(1, { agent: agentName });
  messageSizeHistogram.record(messageSize, { agent: agentName, direction: 'outgoing' });
  messageProcessingDuration.record(processingTime, { agent: agentName });
}

/**
 * Enregistre une requête LLM
 * FONCTION CRITIQUE pour le calcul Gaianet
 */
export function recordLLMRequest(
  agentName: string,
  model: string,
  inputTokens: number,
  outputTokens: number,
  duration: number,
  success: boolean = true
) {
  llmRequestsCounter.add(1, { agent: agentName, model, success: String(success) });
  llmRequestDuration.record(duration, { agent: agentName, model });
  llmTokensInputCounter.add(inputTokens, { agent: agentName, model });
  llmTokensOutputCounter.add(outputTokens, { agent: agentName, model });
}

/**
 * Enregistre une erreur
 */
export function recordError(agentName: string, errorType: string, operation: string) {
  errorsCounter.add(1, { agent: agentName, error_type: errorType, operation });
}

/**
 * Enregistre des triplets générés (spécifique SofIA)
 */
export function recordTripletsGenerated(count: number) {
  tripletsGeneratedCounter.add(count, { agent: 'sofia' });
}

// ============================================
// TRACKING DES CONNEXIONS ACTIVES
// ============================================

let activeConnections: Record<string, number> = {
  sofia: 0,
  chatbot: 0,
  pulse: 0,
  recommendation: 0,
  themeExtractor: 0,
};

export function updateActiveConnections(agentName: string, delta: number) {
  const normalizedName = agentName.toLowerCase();
  activeConnections[normalizedName] = (activeConnections[normalizedName] || 0) + delta;
}

// Callback pour le gauge des connexions actives
activeConnectionsGauge.addCallback((observableResult) => {
  Object.entries(activeConnections).forEach(([agent, count]) => {
    observableResult.observe(count, { agent });
  });
});

// ============================================
// EXPORT DES MÉTRIQUES POUR LOGS
// ============================================

export function getMetricsSummary() {
  return {
    activeConnections: { ...activeConnections },
    timestamp: new Date().toISOString(),
  };
}
