import { EXCLUDED_URL_PATTERNS } from "./constants"
import { getUserAgentIdsCache } from "./websocket"
import { isSensitiveUrl } from "./utils/url"


function generateUUID(): string {
  return crypto.randomUUID
    ? crypto.randomUUID()
    : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
      const r = (Math.random() * 16) | 0
      const v = c === "x" ? r : (r & 0x3) | 0x8
      return v.toString(16)
    })
}

// === Send message to SofIA ===
export function sendMessageToSofia(socketSofia: any, text: string): void {
  if (!socketSofia?.connected) {
    console.warn("‚ö†Ô∏è SofIA socket not connected")
    return
  }

  // üÜï R√©cup√©rer les IDs depuis le cache
  const agentIds = getUserAgentIdsCache()
  if (!agentIds?.sofia) {
    console.error("‚ùå User agent IDs not initialized")
    return
  }

  const sofiaIds = agentIds.sofia

  const payload = {
    type: 2,
    payload: {
      senderId: sofiaIds.AUTHOR_ID,        // ‚úÖ Dynamique
      senderName: "Extension User",
      message: text,
      messageId: generateUUID(),
      roomId: sofiaIds.ROOM_ID,            // ‚úÖ Dynamique
      channelId: sofiaIds.CHANNEL_ID,      // ‚úÖ Dynamique
      serverId: sofiaIds.SERVER_ID,
      source: "extension",
      attachments: [],
      metadata: {
        channelType: "DM",
        isDm: true,
        targetUserId: sofiaIds.AGENT_ID
      }
    }
  }

  console.log("üì§ Message to SofIA:", payload)
  socketSofia.emit("message", payload)
}

// === Send message to Chatbot ===
export function sendMessageToChatbot(socketBot: any, text: string): void {
  if (!socketBot?.connected) {
    console.warn("‚ö†Ô∏è Chatbot socket not connected")
    return
  }

  // üÜï R√©cup√©rer les IDs depuis le cache
  const agentIds = getUserAgentIdsCache()
  if (!agentIds?.chatbot) {
    console.error("‚ùå User agent IDs not initialized")
    return
  }

  const chatbotIds = agentIds.chatbot

  const payload = {
    type: 2,
    payload: {
      senderId: chatbotIds.AUTHOR_ID,
      senderName: "Chat User",
      message: text,
      messageId: generateUUID(),
      roomId: chatbotIds.ROOM_ID,
      channelId: chatbotIds.CHANNEL_ID,
      serverId: chatbotIds.SERVER_ID,
      source: "Chat",
      attachments: [],
      metadata: {
        channelType: "DM",
        isDm: true,
        targetUserId: chatbotIds.AGENT_ID
      }
    }
  }

  console.log("üì§ Message to Chatbot:", payload)
  socketBot.emit("message", payload)
}

// === Configuration ===
const THEME_EXTRACTOR_TIMEOUT = 600000 // 10 minutes


// Global handler for ThemeExtractor responses
let globalThemeExtractorHandler: ((themes: any) => void) | null = null


// === Function to handle ThemeExtractor response with themes data ===
export function handleThemeExtractorResponse(rawData: any): void {
  if (globalThemeExtractorHandler) {
    // Parse themes from agent response format [{"themes": [...]}]
    let themes = []
    if (Array.isArray(rawData) && rawData.length > 0 && rawData[0].themes) {
      themes = rawData[0].themes
    } else if (rawData?.themes) {
      themes = rawData.themes
    }
    
    console.log("üé® Extracted themes:", themes.length, "themes found")
    globalThemeExtractorHandler(themes)
    globalThemeExtractorHandler = null
  }
}

// === Utility functions for bookmarks ===
function extractBookmarkUrls(bookmarkNodes: chrome.bookmarks.BookmarkTreeNode[]): string[] {
  const urls: string[] = []
  
  function traverseBookmarks(nodes: chrome.bookmarks.BookmarkTreeNode[]) {
    for (const node of nodes) {
      if (node.url) {
        urls.push(node.url)
      }
      if (node.children) {
        traverseBookmarks(node.children)
      }
    }
  }
  
  traverseBookmarks(bookmarkNodes)
  return urls
}

export async function sendHistoryToThemeExtractor(socketThemeExtractor: any, urls: string[]): Promise<{success: boolean, themes: any[], message: string}> {
  return processThemeExtraction(socketThemeExtractor, urls, 'history')
}

export async function getAllBookmarks(): Promise<{ success: boolean; urls?: string[]; error?: string }> {
  try {
    const bookmarkTree = await chrome.bookmarks.getTree()
    const allUrls = extractBookmarkUrls(bookmarkTree)
    
    // Limit to 200 most recent bookmarks to avoid prompt being too long
    const urls = allUrls.slice(0, 200)
    
    console.log(`üìö Extracted ${allUrls.length} bookmarks, using ${urls.length} (limited)`)
    
    return { success: true, urls }
  } catch (error) {
    console.error("‚ùå Failed to get bookmarks:", error)
    return { success: false, error: error.message }
  }
}

export async function getAllHistory(): Promise<{success: boolean, urls?: string[], error?: string}> {
  try {
    // Get last 300 history items (most recent visits)
    const historyItems = await chrome.history.search({
      text: '',
      maxResults: 300 // Just the 300 most recent visits
    })
    
    // Extract URLs and filter out sensitive ones
    
    const urls = historyItems
      .map(item => item.url)
      .filter((url): url is string => !!url && !isSensitiveUrl(url))
      .filter(url => !EXCLUDED_URL_PATTERNS.some(pattern => url.includes(pattern)))
    
    console.log('üìö Extracted', urls.length, 'history URLs')
    return { success: true, urls }
  } catch (error) {
    console.error('‚ùå Failed to get browsing history:', error)
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' }
  }
}


// === Unified Theme Extractor processor ===
class ThemeExtractorProcessor {
  private socket: any
  private isProcessing = false
  private type: string

  constructor(socket: any, type: 'bookmark' | 'history' = 'bookmark') {
    this.socket = socket
    this.type = type
  }

  async processUrlsForThemes(urls: string[]): Promise<{success: boolean, themes: any[], message: string}> {
    if (this.isProcessing) {
      throw new Error(`${this.type} ThemeExtractor processing already in progress`)
    }

    if (!this.socket?.connected) {
      throw new Error('ThemeExtractor socket not connected')
    }

    this.isProcessing = true
    console.log(`üé® Starting ${this.type} theme extraction:`, urls.length, 'URLs')

    try {
      const themes = await this.sendForThemes(urls)
      console.log(`‚úÖ ${this.type} theme extraction completed:`, themes.length, 'themes')
      
      return {
        success: true,
        themes,
        message: `Successfully extracted themes from ${urls.length} ${this.type} URLs`
      }

    } catch (error) {
      console.error(`‚ùå ${this.type} theme extraction failed:`, error)
      throw error
    } finally {
      this.isProcessing = false
    }
  }

  private async sendForThemes(urls: string[]): Promise<any[]> {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error(`Timeout waiting for themes from ${this.type}`))
      }, THEME_EXTRACTOR_TIMEOUT)

      // üÜï R√©cup√©rer les IDs depuis le cache
      const agentIds = getUserAgentIdsCache()
      if (!agentIds?.themeExtractor) {
        reject(new Error("User agent IDs not initialized"))
        return
      }

      const themeExtractorIds = agentIds.themeExtractor

      const payload = {
        type: 2,
        payload: {
          senderId: themeExtractorIds.AUTHOR_ID,
          senderName: "Extension",
          message: JSON.stringify({ urls }),
          messageId: generateUUID(),
          roomId: themeExtractorIds.ROOM_ID,
          channelId: themeExtractorIds.CHANNEL_ID,
          serverId: themeExtractorIds.SERVER_ID,
          source: "theme-extraction",
          attachments: [],
          metadata: {
            channelType: "DM",
            isDm: true,
            targetUserId: themeExtractorIds.AGENT_ID
          }
        }
      }

      // Store resolver for when themes come back (will be resolved in websocket handler)
      globalThemeExtractorHandler = (themes) => {
        clearTimeout(timeout)
        resolve(themes || [])
      }

      this.socket.emit("message", payload)
      console.log(`üì§ Sent ${this.type} request with ${urls.length} URLs`)
    })
  }

}


// Generic theme extractor function
async function processThemeExtraction(socketThemeExtractor: any, urls: string[], type: 'bookmark' | 'history'): Promise<{success: boolean, themes: any[], message: string}> {
  if (!socketThemeExtractor) {
    console.error("‚ùå ThemeExtractor socket is null/undefined")
    return { 
      success: false, 
      themes: [],
      message: 'ThemeExtractor not available'
    }
  }

  const processor = new ThemeExtractorProcessor(socketThemeExtractor, type)
  
  try {
    const result = await processor.processUrlsForThemes(urls)
    console.log(`üé® ${type} theme extraction completed:`, result.themes.length, 'themes found')
    return result
  } catch (error) {
    console.error(`‚ùå ${type} theme extraction failed:`, error)
    return { 
      success: false, 
      themes: [],
      message: `Failed to extract ${type} themes: ${error.message}`
    }
  }
}

export async function sendBookmarksToThemeExtractor(socketThemeExtractor: any, urls: string[]): Promise<{success: boolean, themes: any[], message: string}> {
  return processThemeExtraction(socketThemeExtractor, urls, 'bookmark')
}

// === Send pulse data to PulseAgent ===
export function sendMessageToPulse(socketPulse: any, pulseData: any[]): void {
  if (!socketPulse?.connected) {
    console.warn("‚ö†Ô∏è PulseAgent socket not connected")
    return
  }

  // üÜï R√©cup√©rer les IDs depuis le cache
  const agentIds = getUserAgentIdsCache()
  if (!agentIds?.pulse) {
    console.error("‚ùå User agent IDs not initialized")
    return
  }

  const pulseIds = agentIds.pulse

  const payload = {
    type: 2,
    payload: {
      senderId: pulseIds.AUTHOR_ID,
      senderName: "Extension Pulse",
      message: `Analyze current pulse data:\n${JSON.stringify(pulseData)}`,
      messageId: generateUUID(),
      roomId: pulseIds.ROOM_ID,
      channelId: pulseIds.CHANNEL_ID,
      serverId: pulseIds.SERVER_ID,
      source: "pulse-analysis",
      attachments: [],
      metadata: {
        channelType: "DM",
        isDm: true,
        targetUserId: pulseIds.AGENT_ID
      }
    }
  }

  console.log("üì§ Message to PulseAgent:", {
    totalTabs: pulseData.length,
    sampleData: pulseData.slice(0, 2).map(d => ({ url: d.url, title: d.title?.slice(0, 30) }))
  })
  socketPulse.emit("message", payload)
}

// === Send recommendation request to RecommendationAgent ===
export function sendRequestToRecommendation(socketRecommendation: any, walletData: any): void {
  if (!socketRecommendation?.connected) {
    console.warn("‚ö†Ô∏è RecommendationAgent socket not connected")
    return
  }

  // üÜï R√©cup√©rer les IDs depuis le cache
  const agentIds = getUserAgentIdsCache()
  if (!agentIds?.recommendation) {
    console.error("‚ùå User agent IDs not initialized")
    return
  }

  const recommendationIds = agentIds.recommendation

  // Extract key interests from triplets (summarize to avoid token limit)
  const interests = walletData.triples.map((t: any) => ({
    predicate: t.predicate.label,
    object: t.object.label
  }))

  // Group by predicate for cleaner summary
  const summary: Record<string, string[]> = {}
  interests.forEach((i: any) => {
    if (!summary[i.predicate]) summary[i.predicate] = []
    if (!summary[i.predicate].includes(i.object)) {
      summary[i.predicate].push(i.object)
    }
  })

  // Simple, compact message
  const messageText = `Wallet: ${walletData.address}
Total activities: ${walletData.triples.length}

User interests summary:
${Object.entries(summary).map(([pred, objects]) =>
  `- ${pred}: ${objects.join(', ')}`
).join('\n')}`

  const payload = {
    type: 2,
    payload: {
      senderId: recommendationIds.AUTHOR_ID,
      senderName: "Extension Recommendation",
      message: messageText,
      messageId: generateUUID(),
      roomId: recommendationIds.ROOM_ID,
      channelId: recommendationIds.CHANNEL_ID,
      serverId: recommendationIds.SERVER_ID,
      source: "recommendation-generation",
      attachments: [],
      metadata: {
        channelType: "DM",
        isDm: true,
        targetUserId: recommendationIds.AGENT_ID
      }
    }
  }

  console.log("üì§ Message to RecommendationAgent:", {
    wallet: walletData.address,
    triplesCount: walletData.triples.length
  })
  socketRecommendation.emit("message", payload)
}

// === Ollama requests via background ===
export async function sendOllamaRequest(url: string, options: RequestInit): Promise<any> {
  return new Promise((resolve, reject) => {
    chrome.runtime.sendMessage(
      {
        type: "OLLAMA_REQUEST",
        data: { 
          url: url,
          method: options.method,
          headers: options.headers,
          body: options.body
        }
      },
      (response) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError.message));
          return;
        }
        
        if (response.success) {
          resolve(response.data);
        } else {
          reject(new Error(response.error));
        }
      }
    );
  });
}