import { io, Socket } from "socket.io-client"
import {
  SOFIA_BASE_IDS,
  CHATBOT_BASE_IDS,
  THEMEEXTRACTOR_BASE_IDS,
  PULSEAGENT_BASE_IDS,
  RECOMMENDATION_BASE_IDS
} from "./constants"
import { getUserAgentIds, getWalletAddress, type AgentIds } from "../lib/services/UserSessionManager"
import { elizaDataService, agentChannelsService } from "../lib/database/indexedDB-methods"
import { sofiaDB, STORES } from "../lib/database/indexedDB"
import { SOFIA_SERVER_URL } from "../config"

/**
 * üÜï Extract text from ElizaOS message with fallback chain
 * Handles different message formats from ElizaOS server
 */
function extractMessageText(data: any): string {
  return (
    data.text ||
    data.content?.text ||
    data.payload?.content?.text ||
    data.message ||
    data.payload?.message ||
    ""
  )
}

let socketSofia: Socket
let socketBot: Socket
let socketThemeExtractor: Socket
let socketPulse: Socket
let socketRecommendation: Socket

// Cache des IDs utilisateur (g√©n√©r√© une fois au d√©marrage)
let userAgentIds: {
  sofia: AgentIds
  chatbot: AgentIds
  themeExtractor: AgentIds
  pulse: AgentIds
  recommendation: AgentIds
} | null = null

// üÜï Cache for ElizaOS-assigned room IDs (generated by Bootstrap for DMs)
let elizaRoomIds: {
  sofia?: string
  chatbot?: string
  themeExtractor?: string
  pulse?: string
  recommendation?: string
} = {}

/**
 * Initialize user agent IDs (called once at extension startup)
 */
export async function initializeUserAgentIds(): Promise<void> {
  userAgentIds = {
    sofia: await getUserAgentIds("SofIA", SOFIA_BASE_IDS.AGENT_ID),
    chatbot: await getUserAgentIds("ChatBot", CHATBOT_BASE_IDS.AGENT_ID),
    themeExtractor: await getUserAgentIds("ThemeExtractor", THEMEEXTRACTOR_BASE_IDS.AGENT_ID),
    pulse: await getUserAgentIds("PulseAgent", PULSEAGENT_BASE_IDS.AGENT_ID),
    recommendation: await getUserAgentIds("RecommendationAgent", RECOMMENDATION_BASE_IDS.AGENT_ID)
  }

  console.log("‚úÖ User agent IDs initialized:", userAgentIds)
}

/**
 * Export pour utilisation dans d'autres fichiers
 */
export function getUserAgentIdsCache() {
  return userAgentIds
}

/**
 * Export ElizaOS-assigned room IDs for use in message senders
 */
export function getElizaRoomIds() {
  return elizaRoomIds
}

// Export sockets for direct access
export function getSofiaSocket(): Socket { return socketSofia }
export function getChatbotSocket(): Socket { return socketBot }
export function getThemeExtractorSocket(): Socket { return socketThemeExtractor }
export function getPulseSocket(): Socket { return socketPulse }
export function getRecommendationSocket(): Socket { return socketRecommendation }

// Common WebSocket configuration
const commonSocketConfig = {
  transports: ["websocket"],
  path: "/socket.io",
  reconnection: true,
  reconnectionDelay: 5000,        // üî• 5 secondes au lieu de 1 (r√©duit les reconnections spam)
  reconnectionDelayMax: 30000,     // üî• Max 30 secondes entre reconnections
  reconnectionAttempts: Infinity,  // üî• Toujours essayer de reconnecter (mais avec d√©lai long)
  timeout: 20000
}


// === 1. Initialiser WebSocket pour SofIA ===
export async function initializeSofiaSocket(): Promise<void> {
  // üÜï S'assurer que les IDs sont initialis√©s
  if (!userAgentIds) {
    await initializeUserAgentIds()
  }

  const sofiaIds = userAgentIds!.sofia

  // üî• FIX: Prevent socket duplication - disconnect old socket if exists
  if (socketSofia?.connected) {
    console.log("‚ö†Ô∏è SofIA socket already connected, skipping re-initialization")
    return
  }
  if (socketSofia) {
    socketSofia.removeAllListeners()
    socketSofia.disconnect()
  }

  socketSofia = io(SOFIA_SERVER_URL, commonSocketConfig)

  socketSofia.on("connect", async () => {
    console.log("‚úÖ Connected to Eliza (SofIA), socket ID:", socketSofia.id)
    console.log("üîë Using user-specific IDs:", sofiaIds)

    // üÜï V√©rifier si un channel existe d√©j√† pour ce user
    try {
      const walletAddress = await getWalletAddress()
      const storedChannelId = await agentChannelsService.getStoredChannelId(walletAddress, "SofIA")

      if (storedChannelId) {
        // ‚ôªÔ∏è R√©utiliser le channel existant
        sofiaIds.ROOM_ID = storedChannelId
        sofiaIds.CHANNEL_ID = storedChannelId
        console.log("‚ôªÔ∏è [SofIA] Reusing existing channel:", storedChannelId)
        return  // Ne pas cr√©er de nouveau channel
      }

      // üÜï Pas de channel existant ‚Üí cr√©er via REST API
      console.log("üîß [SofIA] No existing channel, creating new one via REST API...")
      const response = await fetch(`${SOFIA_SERVER_URL}/api/messaging/central-channels`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: `DM-SofIA-${Date.now()}`,
          type: 2, // ChannelType.DM
          server_id: sofiaIds.SERVER_ID,
          participantCentralUserIds: [sofiaIds.AUTHOR_ID, sofiaIds.AGENT_ID],
          metadata: {
            isDm: true,
            source: "extension",
            createdAt: new Date().toISOString()
          }
        })
      })

      if (response.ok) {
        const result = await response.json()
        const channelData = result.data || result
        console.log("‚úÖ [SofIA] DM channel created via REST API:", channelData)

        // Store the real channel ID returned by the API
        if (channelData.id) {
          sofiaIds.ROOM_ID = channelData.id
          sofiaIds.CHANNEL_ID = channelData.id
          console.log("üíæ [SofIA] Updated ROOM_ID and CHANNEL_ID to use real channel ID:", sofiaIds.ROOM_ID)

          // üÜï Persister le channel dans IndexedDB
          await agentChannelsService.storeChannelId(walletAddress, "SofIA", channelData.id, sofiaIds.AGENT_ID)
          console.log("üíæ [SofIA] Channel ID persisted to IndexedDB")

          // ‚úÖ Add agent explicitly to channel (following reference code pattern)
          console.log("üîß [SofIA] Adding agent to channel explicitly...")
          try {
            const addAgentResponse = await fetch(
              `${SOFIA_SERVER_URL}/api/messaging/central-channels/${channelData.id}/agents`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ agentId: sofiaIds.AGENT_ID })
              }
            )

            if (addAgentResponse.ok) {
              console.log("‚úÖ [SofIA] Agent added to channel successfully")
            } else {
              const errorText = await addAgentResponse.text()
              console.warn(`‚ö†Ô∏è [SofIA] Could not add agent: ${addAgentResponse.status} ${errorText}`)
            }
          } catch (addError) {
            console.error("‚ùå [SofIA] Error adding agent to channel:", addError)
          }
        }
      } else {
        const errorText = await response.text()
        console.error("‚ùå [SofIA] Failed to create DM channel:", errorText)
      }
    } catch (error) {
      console.error("‚ùå [SofIA] Error creating DM channel:", error)
    }
  })

  socketSofia.on("messageBroadcast", async (data) => {
    // üÜï Logging d√©taill√© pour debug
    console.log("üì° [SofIA] messageBroadcast received:", {
      channelId: data.channelId,
      senderId: data.senderId,  // üîë L'auteur du message (USER_ID ou AGENT_ID)
      expectedChannelId: sofiaIds.CHANNEL_ID,
      expectedAgentId: sofiaIds.AGENT_ID,
      isFromAgent: (data.senderId === sofiaIds.AGENT_ID)
    })

    // ‚úÖ CORRECTION: V√©rifier senderId (pas authorId) - c'est l√† que l'agent ID est envoy√©
    if (
      data.channelId === sofiaIds.CHANNEL_ID &&
      data.senderId === sofiaIds.AGENT_ID
    ) {
      console.log("‚úÖ [SofIA] Agent message matched! Processing...")

      try {
        // üÜï Utiliser extractMessageText pour robustesse
        const messageText = extractMessageText(data)

        // Create message in the exact same format as before
        const newMessage = {
          id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          content: { text: messageText },
          created_at: Date.now(),
          processed: false
        }

        // Store directly in IndexedDB instead of buffer
        await elizaDataService.storeMessage(newMessage, newMessage.id)
        console.log("‚úÖ [SofIA] Message stored in IndexedDB:", { id: newMessage.id, preview: messageText.substring(0, 50) })

        // Clean old messages periodically (keep last 50)
        const allMessages = await elizaDataService.getAllMessages()
        if (allMessages.length > 50) {
          console.log("üßπ Cleaning old messages, keeping 50 most recent")
          await elizaDataService.deleteOldMessages(30) // Keep last 30 days
        }

      } catch (error) {
        console.error("‚ùå [SofIA] Failed to store message in IndexedDB:", error)
      }
    } else {
      console.log("‚è≠Ô∏è [SofIA] Message not for us (from user or different channel)")
    }
  })

  socketSofia.on("disconnect", (reason) => {
    console.warn("üîå SofIA socket disconnected:", reason)
    // üî• FIX: Don't manually reconnect - Socket.IO handles reconnection automatically
    // The reconnection config is already set in commonSocketConfig
  })
}

// === 2. Initialiser WebSocket pour Chatbot ===
export async function initializeChatbotSocket(onReady?: () => void): Promise<void> {
  // üÜï S'assurer que les IDs sont initialis√©s
  if (!userAgentIds) {
    await initializeUserAgentIds()
  }

  const chatbotIds = userAgentIds!.chatbot

  // üî• FIX: Prevent socket duplication
  if (socketBot?.connected) {
    console.log("‚ö†Ô∏è Chatbot socket already connected, skipping re-initialization")
    // üî• FIX: Call callback even if socket already exists (for ChatPage.tsx)
    if (typeof onReady === "function") {
      onReady()
    }
    return
  }
  if (socketBot) {
    socketBot.removeAllListeners()
    socketBot.disconnect()
  }

  socketBot = io(SOFIA_SERVER_URL, commonSocketConfig)

  socketBot.on("connect", async () => {
    console.log("ü§ñ Connected to Chatbot, socket ID:", socketBot.id)
    console.log("üîë Using user-specific IDs:", chatbotIds)

    // üÜï V√©rifier si un channel existe d√©j√† pour ce user
    try {
      const walletAddress = await getWalletAddress()
      const storedChannelId = await agentChannelsService.getStoredChannelId(walletAddress, "ChatBot")

      if (storedChannelId) {
        // ‚ôªÔ∏è R√©utiliser le channel existant
        chatbotIds.ROOM_ID = storedChannelId
        chatbotIds.CHANNEL_ID = storedChannelId
        console.log("‚ôªÔ∏è [Chatbot] Reusing existing channel:", storedChannelId)

        // ‚úÖ Notification that socket is ready
        if (typeof onReady === "function") {
          onReady()
        }
        return  // Ne pas cr√©er de nouveau channel
      }

      // üÜï Pas de channel existant ‚Üí cr√©er via REST API
      console.log("üîß [Chatbot] No existing channel, creating new one via REST API...")
      const response = await fetch(`${SOFIA_SERVER_URL}/api/messaging/central-channels`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: `DM-Chatbot-${Date.now()}`,
          type: 2, // ChannelType.DM
          server_id: chatbotIds.SERVER_ID,
          participantCentralUserIds: [chatbotIds.AUTHOR_ID, chatbotIds.AGENT_ID],
          metadata: {
            isDm: true,
            user1: chatbotIds.AUTHOR_ID,
            user2: chatbotIds.AGENT_ID,
            forAgent: chatbotIds.AGENT_ID,
            source: "extension",
            createdAt: new Date().toISOString()
          }
        })
      })

      if (response.ok) {
        const result = await response.json()
        const channelData = result.data || result
        console.log("‚úÖ [Chatbot] DM channel created via REST API:", channelData)

        // Store the real channel ID returned by the API
        if (channelData.id) {
          chatbotIds.ROOM_ID = channelData.id
          chatbotIds.CHANNEL_ID = channelData.id  // Also update CHANNEL_ID to match
          console.log("üíæ [Chatbot] Updated ROOM_ID and CHANNEL_ID to use real channel ID:", chatbotIds.ROOM_ID)

          // üÜï Persister le channel dans IndexedDB
          await agentChannelsService.storeChannelId(walletAddress, "ChatBot", channelData.id, chatbotIds.AGENT_ID)
          console.log("üíæ [Chatbot] Channel ID persisted to IndexedDB")

          // ‚úÖ Add agent explicitly to channel (following reference code pattern)
          console.log("üîß [Chatbot] Adding agent to channel explicitly...")
          try {
            const addAgentResponse = await fetch(
              `${SOFIA_SERVER_URL}/api/messaging/central-channels/${channelData.id}/agents`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ agentId: chatbotIds.AGENT_ID })
              }
            )

            if (addAgentResponse.ok) {
              console.log("‚úÖ [Chatbot] Agent added to channel successfully")
            } else {
              const errorText = await addAgentResponse.text()
              console.warn(`‚ö†Ô∏è [Chatbot] Could not add agent: ${addAgentResponse.status} ${errorText}`)
              // Note: 409 Conflict means agent already exists - that's OK
            }
          } catch (addError) {
            console.error("‚ùå [Chatbot] Error adding agent to channel:", addError)
          }
        }
      } else {
        const errorText = await response.text()
        console.error("‚ùå [Chatbot] Failed to create DM channel:", errorText)
      }
    } catch (error) {
      console.error("‚ùå [Chatbot] Error creating DM channel:", error)
    }

    // ‚úÖ Notification that socket is ready
    if (typeof onReady === "function") {
      onReady()
    }
  })

  socketBot.on("messageBroadcast", (data) => {
    // üÜï Logging d√©taill√© pour debug
    console.log("üì° [Chatbot] messageBroadcast received:", {
      channelId: data.channelId,
      senderId: data.senderId,  // üîë L'auteur du message (USER_ID ou AGENT_ID)
      expectedChannelId: chatbotIds.CHANNEL_ID,
      expectedAgentId: chatbotIds.AGENT_ID,
      isFromAgent: (data.senderId === chatbotIds.AGENT_ID)
    })

    // ‚úÖ CORRECTION: V√©rifier senderId (pas authorId) - c'est l√† que l'agent ID est envoy√©
    if (
      data.channelId === chatbotIds.CHANNEL_ID &&
      data.senderId === chatbotIds.AGENT_ID
    ) {
      console.log("‚úÖ [Chatbot] Agent response matched! Sending to UI...")

      try {
        // üÜï Utiliser extractMessageText pour robustesse
        const messageText = extractMessageText(data)

        // Envoyer directement via chrome.runtime.sendMessage (pas via MessageBus)
        chrome.runtime.sendMessage({
          type: "CHATBOT_RESPONSE",
          text: messageText
        }).catch((error) => {
          console.warn("‚ö†Ô∏è [Chatbot] Error sending CHATBOT_RESPONSE:", error)
        })

        console.log("‚úÖ [Chatbot] Response sent to UI:", messageText.substring(0, 50))
      } catch (error) {
        console.warn("‚ö†Ô∏è [Chatbot] Error processing message:", error)
      }
    } else {
      console.log("‚è≠Ô∏è [Chatbot] Message not for us (from user or different channel)")
    }
  })

  socketBot.on("disconnect", (reason) => {
    console.warn("üîå Chatbot socket disconnected:", reason)
    // üî• FIX: Don't manually reconnect - Socket.IO handles it automatically
  })
}

// === 3. Direct theme analysis functions ===
// TODO: Re-implement these functions after refactoring
// export async function processBookmarksWithThemeAnalysis(urls: string[]): Promise<{success: boolean, message: string, themesExtracted: number, triplesProcessed: boolean}> {
//   return await processUrlsWithThemeAnalysis(
//     urls,
//     'bookmark',
//     (urls) => sendBookmarksToThemeExtractor(socketThemeExtractor, urls),
//     'Bookmark analysis completed'
//   )
// }

// export async function processHistoryWithThemeAnalysis(urls: string[]): Promise<{success: boolean, message: string, themesExtracted: number, triplesProcessed: boolean}> {
//   return await processUrlsWithThemeAnalysis(
//     urls,
//     'history',
//     (urls) => sendHistoryToThemeExtractor(socketThemeExtractor, urls),
//     'History analysis completed'
//   )
// }



// === 3. Initialiser WebSocket pour ThemeExtractor ===
export async function initializeThemeExtractorSocket(): Promise<void> {
  // üÜï S'assurer que les IDs sont initialis√©s
  if (!userAgentIds) {
    await initializeUserAgentIds()
  }

  const themeExtractorIds = userAgentIds!.themeExtractor

  // üî• FIX: Prevent socket duplication
  if (socketThemeExtractor?.connected) {
    console.log("‚ö†Ô∏è ThemeExtractor socket already connected, skipping re-initialization")
    return
  }
  if (socketThemeExtractor) {
    socketThemeExtractor.removeAllListeners()
    socketThemeExtractor.disconnect()
  }

  socketThemeExtractor = io(SOFIA_SERVER_URL, commonSocketConfig)

  socketThemeExtractor.on("connect", async () => {
    console.log("‚úÖ [websocket.ts] Connected to ThemeExtractor, socket ID:", socketThemeExtractor.id)
    console.log("üîë Using user-specific IDs:", themeExtractorIds)

    // üÜï Check if channel already exists for this user
    try {
      const walletAddress = await getWalletAddress()
      const storedChannelId = await agentChannelsService.getStoredChannelId(walletAddress, "ThemeExtractor")

      if (storedChannelId) {
        // ‚ôªÔ∏è Reuse existing channel
        themeExtractorIds.ROOM_ID = storedChannelId
        themeExtractorIds.CHANNEL_ID = storedChannelId
        console.log(`‚ôªÔ∏è [ThemeExtractor] Reusing existing channel: ${storedChannelId}`)
        return  // Don't create a new channel
      }

      // üÜï No existing channel ‚Üí create via REST API
      console.log("üîß [ThemeExtractor] Creating DM channel via REST API (following reference pattern)...")
      const response = await fetch(`${SOFIA_SERVER_URL}/api/messaging/central-channels`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: `DM-ThemeExtractor-${Date.now()}`,
          type: 2, // ChannelType.DM
          server_id: themeExtractorIds.SERVER_ID,
          participantCentralUserIds: [themeExtractorIds.AUTHOR_ID, themeExtractorIds.AGENT_ID],
          metadata: {
            isDm: true,
            user1: themeExtractorIds.AUTHOR_ID,
            user2: themeExtractorIds.AGENT_ID,
            forAgent: themeExtractorIds.AGENT_ID,
            source: "extension",
            createdAt: new Date().toISOString()
          }
        })
      })

      if (response.ok) {
        const result = await response.json()
        const channelData = result.data || result
        console.log("‚úÖ [ThemeExtractor] DM channel created via REST API:", channelData)

        // Store the real channel ID returned by the API
        if (channelData.id) {
          themeExtractorIds.ROOM_ID = channelData.id
          themeExtractorIds.CHANNEL_ID = channelData.id
          console.log("üíæ [ThemeExtractor] Updated ROOM_ID and CHANNEL_ID to use real channel ID:", themeExtractorIds.ROOM_ID)

          // üÜï Persist channel in IndexedDB
          await agentChannelsService.storeChannelId(walletAddress, "ThemeExtractor", channelData.id, themeExtractorIds.AGENT_ID)
          console.log("üíæ [ThemeExtractor] Channel persisted in IndexedDB")

          // ‚úÖ Add agent explicitly to channel (following reference code pattern)
          console.log("üîß [ThemeExtractor] Adding agent to channel explicitly...")
          try {
            const addAgentResponse = await fetch(
              `${SOFIA_SERVER_URL}/api/messaging/central-channels/${channelData.id}/agents`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ agentId: themeExtractorIds.AGENT_ID })
              }
            )

            if (addAgentResponse.ok) {
              console.log("‚úÖ [ThemeExtractor] Agent added to channel successfully")
            } else {
              const errorText = await addAgentResponse.text()
              console.warn(`‚ö†Ô∏è [ThemeExtractor] Could not add agent: ${addAgentResponse.status} ${errorText}`)
            }
          } catch (addError) {
            console.error("‚ùå [ThemeExtractor] Error adding agent to channel:", addError)
          }
        }
      } else {
        const errorText = await response.text()
        console.error("‚ùå [ThemeExtractor] Failed to create DM channel:", errorText)
      }
    } catch (error) {
      console.error("‚ùå [ThemeExtractor] Error creating DM channel:", error)
    }
  })

  socketThemeExtractor.on("messageBroadcast", async (data) => {
    console.log("üì° [ThemeExtractor] messageBroadcast received:", {
      channelId: data.channelId,
      senderId: data.senderId,  // üîë L'auteur du message (USER_ID ou AGENT_ID)
      expectedChannelId: themeExtractorIds.CHANNEL_ID,
      expectedAgentId: themeExtractorIds.AGENT_ID,
      isFromAgent: (data.senderId === themeExtractorIds.AGENT_ID)
    })

    // ‚úÖ CORRECTION: V√©rifier senderId (pas authorId) - c'est l√† que l'agent ID est envoy√©
    if (
      data.channelId === themeExtractorIds.CHANNEL_ID &&
      data.senderId === themeExtractorIds.AGENT_ID
    ) {
      console.log("‚úÖ [ThemeExtractor] Agent response matched! Processing themes...")

      try {
        const messageText = extractMessageText(data)
        console.log("üîç [ThemeExtractor] Raw message:", messageText.substring(0, 100))

        // Parse themes from the response
        let themes = []
        try {
          const parsed = JSON.parse(messageText)
          themes = parsed
          console.log("üé® [ThemeExtractor] Themes parsed successfully:", themes)
        } catch (parseError) {
          console.warn("‚ö†Ô∏è [ThemeExtractor] Could not parse themes as JSON:", parseError)
          themes = []
        }

        // TODO: Re-implement theme extraction handler
        // handleThemeExtractorResponse(themes)
        console.log("üé® [ThemeExtractor] Theme extraction result:", themes)

      } catch (error) {
        console.error("‚ùå [ThemeExtractor] Failed to process response:", error)
      }
    } else {
      console.log("‚è≠Ô∏è [ThemeExtractor] Message not for us (from user or different channel)")
    }
  })

  socketThemeExtractor.on("connect_error", (error) => {
    console.error("‚ùå [websocket.ts] ThemeExtractor connection error:", error)
  })

  socketThemeExtractor.on("disconnect", (reason) => {
    console.warn("üîå [websocket.ts] ThemeExtractor socket disconnected:", reason)
    // üî• FIX: Don't manually reconnect - Socket.IO handles it automatically
  })
  
  console.log("üé® [websocket.ts] ThemeExtractor socket initialization completed")
}

// === 4. Initialiser WebSocket pour PulseAgent ===
export async function initializePulseSocket(): Promise<void> {
  // üÜï S'assurer que les IDs sont initialis√©s
  if (!userAgentIds) {
    await initializeUserAgentIds()
  }

  const pulseIds = userAgentIds!.pulse

  // üî• FIX: Prevent socket duplication
  if (socketPulse?.connected) {
    console.log("‚ö†Ô∏è PulseAgent socket already connected, skipping re-initialization")
    return
  }
  if (socketPulse) {
    socketPulse.removeAllListeners()
    socketPulse.disconnect()
  }

  socketPulse = io(SOFIA_SERVER_URL, commonSocketConfig)

  socketPulse.on("connect", async () => {
    console.log("‚úÖ [websocket.ts] Connected to PulseAgent, socket ID:", socketPulse.id)
    console.log("üîë Using user-specific IDs:", pulseIds)

    // üÜï Check if channel already exists for this user
    try {
      const walletAddress = await getWalletAddress()
      const storedChannelId = await agentChannelsService.getStoredChannelId(walletAddress, "PulseAgent")

      if (storedChannelId) {
        // ‚ôªÔ∏è Reuse existing channel
        pulseIds.ROOM_ID = storedChannelId
        pulseIds.CHANNEL_ID = storedChannelId
        console.log(`‚ôªÔ∏è [PulseAgent] Reusing existing channel: ${storedChannelId}`)
        return  // Don't create a new channel
      }

      // üÜï No existing channel ‚Üí create via REST API
      console.log("üîß [PulseAgent] Creating DM channel via REST API (following reference pattern)...")
      const response = await fetch(`${SOFIA_SERVER_URL}/api/messaging/central-channels`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: `DM-PulseAgent-${Date.now()}`,
          type: 2, // ChannelType.DM
          server_id: pulseIds.SERVER_ID,
          participantCentralUserIds: [pulseIds.AUTHOR_ID, pulseIds.AGENT_ID],
          metadata: {
            isDm: true,
            user1: pulseIds.AUTHOR_ID,
            user2: pulseIds.AGENT_ID,
            forAgent: pulseIds.AGENT_ID,
            source: "extension",
            createdAt: new Date().toISOString()
          }
        })
      })

      if (response.ok) {
        const result = await response.json()
        const channelData = result.data || result
        console.log("‚úÖ [PulseAgent] DM channel created via REST API:", channelData)

        // Store the real channel ID returned by the API
        if (channelData.id) {
          pulseIds.ROOM_ID = channelData.id
          pulseIds.CHANNEL_ID = channelData.id
          console.log("üíæ [PulseAgent] Updated ROOM_ID and CHANNEL_ID to use real channel ID:", pulseIds.ROOM_ID)

          // üÜï Persist channel in IndexedDB
          await agentChannelsService.storeChannelId(walletAddress, "PulseAgent", channelData.id, pulseIds.AGENT_ID)
          console.log("üíæ [PulseAgent] Channel persisted in IndexedDB")

          // ‚úÖ Add agent explicitly to channel (following reference code pattern)
          console.log("üîß [PulseAgent] Adding agent to channel explicitly...")
          try {
            const addAgentResponse = await fetch(
              `${SOFIA_SERVER_URL}/api/messaging/central-channels/${channelData.id}/agents`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ agentId: pulseIds.AGENT_ID })
              }
            )

            if (addAgentResponse.ok) {
              console.log("‚úÖ [PulseAgent] Agent added to channel successfully")
            } else {
              const errorText = await addAgentResponse.text()
              console.warn(`‚ö†Ô∏è [PulseAgent] Could not add agent: ${addAgentResponse.status} ${errorText}`)
            }
          } catch (addError) {
            console.error("‚ùå [PulseAgent] Error adding agent to channel:", addError)
          }
        }
      } else {
        const errorText = await response.text()
        console.error("‚ùå [PulseAgent] Failed to create DM channel:", errorText)
      }
    } catch (error) {
      console.error("‚ùå [PulseAgent] Error creating DM channel:", error)
    }
  })

  socketPulse.on("messageBroadcast", async (data) => {
    console.log("üì° [PulseAgent] messageBroadcast received:", {
      channelId: data.channelId,
      senderId: data.senderId,  // üîë L'auteur du message (USER_ID ou AGENT_ID)
      expectedChannelId: pulseIds.CHANNEL_ID,
      expectedAgentId: pulseIds.AGENT_ID,
      isFromAgent: (data.senderId === pulseIds.AGENT_ID)
    })

    // ‚úÖ CORRECTION: V√©rifier senderId (pas authorId) - c'est l√† que l'agent ID est envoy√©
    if (
      data.channelId === pulseIds.CHANNEL_ID &&
      data.senderId === pulseIds.AGENT_ID
    ) {
      console.log("‚úÖ [PulseAgent] Agent response matched! Processing pulse analysis...")

      try {
        const messageText = extractMessageText(data)
        console.log("ü´Ä [PulseAgent] Raw message:", messageText.substring(0, 100))

        // Store pulse analysis results directly in IndexedDB
        const pulseRecord = {
          messageId: `pulse_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          content: { text: messageText },
          timestamp: Date.now(),
          type: 'pulse_analysis'
        }

        // Use sofiaDB directly to bypass elizaDataService parsing
        const result = await sofiaDB.put(STORES.ELIZA_DATA, pulseRecord)
        console.log("‚úÖ [PulseAgent] Pulse analysis stored directly:", { id: result, type: pulseRecord.type })

        // Notify UI that pulse analysis is complete
        try {
          chrome.runtime.sendMessage({
            type: "PULSE_ANALYSIS_COMPLETE"
          })
          console.log("ü´Ä [PulseAgent] Sent PULSE_ANALYSIS_COMPLETE message")
        } catch (busError) {
          console.warn("‚ö†Ô∏è [PulseAgent] Failed to send PULSE_ANALYSIS_COMPLETE:", busError)
        }

      } catch (error) {
        console.error("‚ùå [PulseAgent] Failed to store pulse analysis:", error)
      }
    } else {
      console.log("‚è≠Ô∏è [PulseAgent] Message not for us (from user or different channel)")
    }
  })

  socketPulse.on("connect_error", (error) => {
    console.error("‚ùå [websocket.ts] PulseAgent connection error:", error)
  })

  socketPulse.on("disconnect", (reason) => {
    console.warn("üîå [websocket.ts] PulseAgent socket disconnected:", reason)
    // üî• FIX: Don't manually reconnect - Socket.IO handles it automatically
  })

  console.log("ü´Ä [websocket.ts] PulseAgent socket initialization completed")
}

// === 5. Initialiser WebSocket pour RecommendationAgent ===
// Global handler for RecommendationAgent responses
let globalRecommendationHandler: ((recommendations: any) => void) | null = null

export function handleRecommendationResponse(rawData: any): void {
  if (globalRecommendationHandler) {
    console.log("üíé [websocket.ts] Processing recommendation response")
    globalRecommendationHandler(rawData)
    globalRecommendationHandler = null
  }
}

export async function initializeRecommendationSocket(): Promise<void> {
  // üÜï S'assurer que les IDs sont initialis√©s
  if (!userAgentIds) {
    await initializeUserAgentIds()
  }

  const recommendationIds = userAgentIds!.recommendation

  // üî• FIX: Prevent socket duplication
  if (socketRecommendation?.connected) {
    console.log("‚ö†Ô∏è RecommendationAgent socket already connected, skipping re-initialization")
    return
  }
  if (socketRecommendation) {
    socketRecommendation.removeAllListeners()
    socketRecommendation.disconnect()
  }

  socketRecommendation = io(SOFIA_SERVER_URL, commonSocketConfig)

  socketRecommendation.on("connect", async () => {
    console.log("‚úÖ [websocket.ts] Connected to RecommendationAgent, socket ID:", socketRecommendation.id)
    console.log("üîë Using user-specific IDs:", recommendationIds)

    // üÜï Check if channel already exists for this user
    try {
      const walletAddress = await getWalletAddress()
      const storedChannelId = await agentChannelsService.getStoredChannelId(walletAddress, "RecommendationAgent")

      if (storedChannelId) {
        // ‚ôªÔ∏è Reuse existing channel
        recommendationIds.ROOM_ID = storedChannelId
        recommendationIds.CHANNEL_ID = storedChannelId
        console.log(`‚ôªÔ∏è [RecommendationAgent] Reusing existing channel: ${storedChannelId}`)
        return  // Don't create a new channel
      }

      // üÜï No existing channel ‚Üí create via REST API
      console.log("üîß [RecommendationAgent] Creating DM channel via REST API (following reference pattern)...")
      const response = await fetch(`${SOFIA_SERVER_URL}/api/messaging/central-channels`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: `DM-RecommendationAgent-${Date.now()}`,
          type: 2, // ChannelType.DM
          server_id: recommendationIds.SERVER_ID,
          participantCentralUserIds: [recommendationIds.AUTHOR_ID, recommendationIds.AGENT_ID],
          metadata: {
            isDm: true,
            user1: recommendationIds.AUTHOR_ID,
            user2: recommendationIds.AGENT_ID,
            forAgent: recommendationIds.AGENT_ID,
            source: "extension",
            createdAt: new Date().toISOString()
          }
        })
      })

      if (response.ok) {
        const result = await response.json()
        const channelData = result.data || result
        console.log("‚úÖ [RecommendationAgent] DM channel created via REST API:", channelData)

        // Store the real channel ID returned by the API
        if (channelData.id) {
          recommendationIds.ROOM_ID = channelData.id
          recommendationIds.CHANNEL_ID = channelData.id
          console.log("üíæ [RecommendationAgent] Updated ROOM_ID and CHANNEL_ID to use real channel ID:", recommendationIds.ROOM_ID)

          // üÜï Persist channel in IndexedDB
          await agentChannelsService.storeChannelId(walletAddress, "RecommendationAgent", channelData.id, recommendationIds.AGENT_ID)
          console.log("üíæ [RecommendationAgent] Channel persisted in IndexedDB")

          // ‚úÖ Add agent explicitly to channel (following reference code pattern)
          console.log("üîß [RecommendationAgent] Adding agent to channel explicitly...")
          try {
            const addAgentResponse = await fetch(
              `${SOFIA_SERVER_URL}/api/messaging/central-channels/${channelData.id}/agents`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ agentId: recommendationIds.AGENT_ID })
              }
            )

            if (addAgentResponse.ok) {
              console.log("‚úÖ [RecommendationAgent] Agent added to channel successfully")
            } else {
              const errorText = await addAgentResponse.text()
              console.warn(`‚ö†Ô∏è [RecommendationAgent] Could not add agent: ${addAgentResponse.status} ${errorText}`)
            }
          } catch (addError) {
            console.error("‚ùå [RecommendationAgent] Error adding agent to channel:", addError)
          }
        }
      } else {
        const errorText = await response.text()
        console.error("‚ùå [RecommendationAgent] Failed to create DM channel:", errorText)
      }
    } catch (error) {
      console.error("‚ùå [RecommendationAgent] Error creating DM channel:", error)
    }
  })

  socketRecommendation.on("messageBroadcast", async (data) => {
    console.log("üì° [RecommendationAgent] messageBroadcast received:", {
      channelId: data.channelId,
      senderId: data.senderId,  // üîë L'auteur du message (USER_ID ou AGENT_ID)
      expectedChannelId: recommendationIds.CHANNEL_ID,
      expectedAgentId: recommendationIds.AGENT_ID,
      isFromAgent: (data.senderId === recommendationIds.AGENT_ID)
    })

    // ‚úÖ CORRECTION: V√©rifier senderId (pas authorId) - c'est l√† que l'agent ID est envoy√©
    if (
      data.channelId === recommendationIds.CHANNEL_ID &&
      data.senderId === recommendationIds.AGENT_ID
    ) {
      console.log("‚úÖ [RecommendationAgent] Agent response matched! Processing recommendations...")

      try {
        const messageText = extractMessageText(data)
        console.log("üíé [RecommendationAgent] Raw message:", messageText.substring(0, 100))

        // Parse recommendations from the response
        let recommendations = null
        try {
          const parsed = JSON.parse(messageText)
          recommendations = parsed
          console.log("üíé [RecommendationAgent] Recommendations parsed successfully:", recommendations)
        } catch (parseError) {
          console.warn("‚ö†Ô∏è [RecommendationAgent] Could not parse recommendations as JSON:", parseError)
          recommendations = null
        }

        // Resolve the Promise so requester can continue
        handleRecommendationResponse(recommendations)

      } catch (error) {
        console.error("‚ùå [RecommendationAgent] Failed to process response:", error)
        handleRecommendationResponse(null)
      }
    } else {
      console.log("‚è≠Ô∏è [RecommendationAgent] Message not for us (from user or different channel)")
    }
  })

  socketRecommendation.on("connect_error", (error) => {
    console.error("‚ùå [websocket.ts] RecommendationAgent connection error:", error)
  })

  socketRecommendation.on("disconnect", (reason) => {
    console.warn("üîå [websocket.ts] RecommendationAgent socket disconnected:", reason)
    // üî• FIX: Don't manually reconnect - Socket.IO handles it automatically
  })

  console.log("üíé [websocket.ts] RecommendationAgent socket initialization completed")
}

// Helper function to send recommendation request and wait for response
export async function sendRecommendationRequest(walletData: any): Promise<any> {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('Timeout waiting for recommendations'))
    }, 60000) // 60 seconds timeout

    // Store resolver for when recommendations come back
    globalRecommendationHandler = (recommendations) => {
      clearTimeout(timeout)
      resolve(recommendations || null)
    }

    // Send the request
    // TODO: Re-implement recommendation request
    // const { sendRequestToRecommendation } = require('./messageSenders')
    // sendRequestToRecommendation(socketRecommendation, walletData)
    console.log("üì§ [websocket.ts] Sent recommendation request for wallet:", walletData?.address)
  })
}

/**
 * Send theme extraction request (stub for now)
 * TODO: Re-implement properly
 */
export async function sendThemeExtractionRequest(urls: string[]): Promise<any[]> {
  console.log("‚ö†Ô∏è [websocket.ts] sendThemeExtractionRequest called but not implemented yet")
  return []
}

/**
 * Send a message to a specific agent via Socket.IO
 * @param agentType - Which agent to send to ('SOFIA', 'CHATBOT', etc.)
 * @param text - Message text to send
 */
export async function sendMessage(agentType: 'SOFIA' | 'CHATBOT' | 'THEMEEXTRACTOR' | 'PULSEAGENT' | 'RECOMMENDATION', text: string): Promise<void> {
  // Ensure IDs are initialized
  if (!userAgentIds) {
    await initializeUserAgentIds()
  }

  // Get the correct socket and IDs based on agent type
  let socket: Socket
  let agentIds: AgentIds

  switch (agentType) {
    case 'SOFIA':
      socket = socketSofia
      agentIds = userAgentIds!.sofia
      break
    case 'CHATBOT':
      socket = socketBot
      agentIds = userAgentIds!.chatbot
      break
    case 'THEMEEXTRACTOR':
      socket = socketThemeExtractor
      agentIds = userAgentIds!.themeExtractor
      break
    case 'PULSEAGENT':
      socket = socketPulse
      agentIds = userAgentIds!.pulse
      break
    case 'RECOMMENDATION':
      socket = socketRecommendation
      agentIds = userAgentIds!.recommendation
      break
    default:
      throw new Error(`Unknown agent type: ${agentType}`)
  }

  if (!socket || !socket.connected) {
    throw new Error(`Socket for ${agentType} is not connected`)
  }

  console.log(`üì§ [${agentType}] Sending message:`, text.substring(0, 100))
  console.log(`üì§ [${agentType}] Complete IDs:`, {
    channelId: agentIds.ROOM_ID,
    serverId: agentIds.SERVER_ID,
    senderId: agentIds.AUTHOR_ID,
    agentId: agentIds.AGENT_ID
  })

  const payload = {
    type: 2,  // SEND_MESSAGE
    payload: {
      channelId: agentIds.ROOM_ID,      // Real channel ID from REST API creation
      serverId: agentIds.SERVER_ID,     // Server ID
      senderId: agentIds.AUTHOR_ID,     // User's entity ID
      message: text,                     // Plain text message
      metadata: {
        source: "extension",
        timestamp: Date.now(),
        user_display_name: "User"         // Display name for user entity creation
      }
    }
  }

  console.log(`üì§ [${agentType}] Full payload:`, JSON.stringify(payload, null, 2))

  // Send message via Socket.IO (type 2 = SEND_MESSAGE)
  // Channel already created via REST API with proper participants
  socket.emit("message", payload)

  console.log(`‚úÖ [${agentType}] Message sent via Socket.IO to channel ${agentIds.ROOM_ID}`)
}

